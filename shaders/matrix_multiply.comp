#version 450
layout (local_size_x = 16, local_size_y = 16) in;

layout(binding = 0) readonly buffer InA {
    float in_a[];
};

layout(binding = 1) readonly buffer InB {
    float in_b[];
};

layout(binding = 2) writeonly buffer Product {
    float product[];
};

layout(push_constant) uniform Sizes {
    uint out_rows; // Rows of in_a, product
    uint out_cols; // Columns of in_b, product
    uint inner_rc; /// Columns of in_a, Rows of in_B
    uint transpose_a; // Multiply as if in_a was transposed
    uint transpose_b; // Multiply as if in_b was transposed
};

uvec2 gid = gl_GlobalInvocationID.xy;

float matmul();
float matmul_aT();
float matmul_bT();
float matmul_aTbT();

void main() {
    if (gid.x >= out_cols || gid.y >= out_rows) return;
    uint output_idx = gid.y * out_cols + gid.x;
    if (bool(transpose_a)) {
        if (bool(transpose_b)) {
            product[output_idx] = matmul_aTbT();
        } else {
            product[output_idx] = matmul_aT();
        }
    } else {
        if (bool(transpose_b)) {
            product[output_idx] = matmul_bT();
        } else {
            product[output_idx] = matmul();
        }
    }
}

float matmul() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        sum += in_a[gid.y * inner_rc + i] * in_b[i * out_cols + gid.x];
    }
    return sum;
}

float matmul_aT() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        sum += in_a[gid.y + inner_rc * i] * in_b[i * out_cols + gid.x];
    }
    return sum;
}

float matmul_bT() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        sum += in_a[gid.y * inner_rc + i] * in_b[i + out_cols * gid.x];
    }
    return sum;
}

float matmul_aTbT() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        sum += in_a[gid.y + inner_rc * i] * in_b[i + out_cols * gid.x];
    }
    return sum;
}
