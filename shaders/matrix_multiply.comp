#version 450
layout (local_size_x = 16, local_size_y = 16, local_size_z = 16) in;
layout (binding=0, r32f) uniform readonly image2DArray in_a;
layout (binding=1, r32f) uniform readonly image2DArray in_b;
layout (binding=2, r32f) uniform writeonly image2DArray product;

layout(push_constant) uniform Sizes {
    uint inner_rc; // Inner size
    uint transpose_a; // Multiply as if in_a was transposed
    uint transpose_b; // Multiply as if in_b was transposed
};

ivec3 gid = ivec3(gl_GlobalInvocationID);

float matmul();
float matmul_aT();
float matmul_bT();
float matmul_aTbT();

void main() {
    ivec3 product_dims = imageSize(product);
    if (product_dims.z >= gid.z || product_dims.y >= gid.y || product_dims.x >= gid.x) return;
    float prod;
    if (bool(transpose_a)) {
        if (bool(transpose_b)) {
            prod = matmul_aTbT();
        } else {
            prod = matmul_aT();
        }
    } else {
        if (bool(transpose_b)) {
            prod = matmul_bT();
        } else {
            prod = matmul();
        }
    }
    imageStore(product, gid, vec4(prod, 0., 0., 0.));
}

float matmul() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        ivec3 a_coord = ivec3(i, gid.y, gid.z);
        ivec3 b_coord = ivec3(gid.x, i, gid.z);
        sum += imageLoad(in_a, a_coord).x * imageLoad(in_b, b_coord).x;
    }
    return sum;
}

float matmul_aT() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        ivec3 a_coord = ivec3(gid.y, i, gid.z);
        ivec3 b_coord = ivec3(gid.x, i, gid.z);
        sum += imageLoad(in_a, a_coord).x * imageLoad(in_b, b_coord).x;
    }
    return sum;
}

float matmul_bT() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        ivec3 a_coord = ivec3(i, gid.y, gid.z);
        ivec3 b_coord = ivec3(i, gid.x, gid.z);
        sum += imageLoad(in_a, a_coord).x * imageLoad(in_b, b_coord).x;
    }
    return sum;
}

float matmul_aTbT() {
    float sum = 0.;
    for (uint i = 0; i < inner_rc; i++) {
        ivec3 a_coord = ivec3(gid.y, i, gid.z);
        ivec3 b_coord = ivec3(i, gid.x, gid.z);
        sum += imageLoad(in_a, a_coord).x * imageLoad(in_b, b_coord).x;
    }
    return sum;
}
